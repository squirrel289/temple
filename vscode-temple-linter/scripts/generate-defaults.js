const fs = require("node:fs");
const path = require("node:path");

const REPO_ROOT = path.resolve(__dirname, "..", "..");
const SHARED_DEFAULTS_PATH = path.join(REPO_ROOT, "shared", "temple-defaults.json");
const PYTHON_DEFAULTS_PATH = path.join(REPO_ROOT, "temple", "src", "temple", "defaults.py");
const TYPESCRIPT_DEFAULTS_PATH = path.join(__dirname, "..", "src", "defaults.ts");
const GENERATED_BANNER = "DO NOT EDIT DIRECTLY. Generated by vscode-temple-linter/scripts/generate-defaults.js.";

function readDefaults() {
  const raw = fs.readFileSync(SHARED_DEFAULTS_PATH, "utf8");
  const parsed = JSON.parse(raw);
  const templeExtensions = Array.isArray(parsed.templeExtensions)
    ? parsed.templeExtensions.filter((entry) => typeof entry === "string")
    : [];
  const templateDelimiters =
    parsed.templateDelimiters && typeof parsed.templateDelimiters === "object"
      ? parsed.templateDelimiters
      : {};
  return { templeExtensions, templateDelimiters };
}

function renderPythonDefaults({ templeExtensions, templateDelimiters }) {
  const delimiterEntries = Object.entries(templateDelimiters).map(([name, pair]) => {
    if (!Array.isArray(pair) || pair.length !== 2) {
      throw new Error(`Invalid delimiter pair for '${name}' in shared defaults.`);
    }
    const [start, end] = pair;
    if (typeof start !== "string" || typeof end !== "string") {
      throw new Error(
        `Invalid delimiter pair for '${name}' in shared defaults: start and end must be strings.`,
      );
    }
    return `    "${name}": (${JSON.stringify(start)}, ${JSON.stringify(end)}),`;
  });

  const extensionTuple = templeExtensions.map((ext) => JSON.stringify(ext)).join(", ");
  const tupleSuffix = templeExtensions.length === 1 ? "," : "";

  return [
    '"""Shared Temple defaults used across tokenizer/parser/linter integrations.',
    "",
    `${GENERATED_BANNER}`,
    '"""',
    "",
    "from __future__ import annotations",
    "",
    "from typing import Final",
    "",
    "DEFAULT_TEMPLATE_DELIMITERS: Final[dict[str, tuple[str, str]]] = {",
    ...delimiterEntries,
    "}",
    "",
    `DEFAULT_TEMPLE_EXTENSIONS: Final[tuple[str, ...]] = (${extensionTuple}${tupleSuffix})`,
    "",
  ].join("\n");
}

function renderTypeScriptDefaults({ templeExtensions }) {
  const serializedExtensions = templeExtensions.map((ext) => JSON.stringify(ext)).join(", ");
  return [
    `// ${GENERATED_BANNER}`,
    "",
    `export const DEFAULT_TEMPLE_EXTENSIONS: string[] = [${serializedExtensions}];`,
    "",
  ].join("\n");
}

function contentChanged(targetPath, nextContent) {
  const currentContent = fs.existsSync(targetPath)
    ? fs.readFileSync(targetPath, "utf8")
    : "";
  return currentContent !== nextContent;
}

function main() {
  const checkMode = process.argv.includes("--check");
  const defaults = readDefaults();
  const pythonContent = renderPythonDefaults(defaults);
  const typeScriptContent = renderTypeScriptDefaults(defaults);

  const changedFiles = [];
  if (contentChanged(PYTHON_DEFAULTS_PATH, pythonContent)) {
    changedFiles.push(PYTHON_DEFAULTS_PATH);
    if (!checkMode) {
      fs.writeFileSync(PYTHON_DEFAULTS_PATH, pythonContent, "utf8");
    }
  }
  if (contentChanged(TYPESCRIPT_DEFAULTS_PATH, typeScriptContent)) {
    changedFiles.push(TYPESCRIPT_DEFAULTS_PATH);
    if (!checkMode) {
      fs.writeFileSync(TYPESCRIPT_DEFAULTS_PATH, typeScriptContent, "utf8");
    }
  }

  if (checkMode && changedFiles.length > 0) {
    for (const changedFile of changedFiles) {
      console.error(`Generated defaults out of date: ${changedFile}`);
    }
    process.exit(1);
  }
}

main();
