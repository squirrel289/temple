"""
This type stub file was generated by pyright.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Set, Union
from enum import Enum

"""
temple.compiler.types
Type system for typed templates.

Defines base types, collections, unions, constraints, and type inference.
"""
class TypeKind(Enum):
    """Enumeration of type kinds in the type system."""
    STRING = ...
    NUMBER = ...
    BOOLEAN = ...
    NULL = ...
    ARRAY = ...
    OBJECT = ...
    TUPLE = ...
    UNION = ...
    REFERENCE = ...
    ANY = ...


@dataclass
class BaseType(ABC):
    """Abstract base class for all types."""
    @abstractmethod
    def is_compatible_with(self, other: BaseType) -> bool:
        """Check if this type is compatible with another type."""
        ...
    
    @abstractmethod
    def validate_value(self, value: Any) -> tuple[bool, Optional[str]]:
        """Validate a value against this type.

        Returns:
            (is_valid, error_message)
        """
        ...
    
    @abstractmethod
    def to_schema(self) -> Dict[str, Any]:
        """Convert type to JSON Schema representation."""
        ...
    


@dataclass
class StringType(BaseType):
    """String type with optional constraints."""
    min_length: Optional[int] = ...
    max_length: Optional[int] = ...
    pattern: Optional[str] = ...
    enum: Optional[List[str]] = ...
    format: Optional[str] = ...
    def is_compatible_with(self, other: BaseType) -> bool:
        """Strings are compatible with other strings (constraints checked separately)."""
        ...
    
    def validate_value(self, value: Any) -> tuple[bool, Optional[str]]:
        """Validate a value is a string meeting constraints."""
        ...
    
    def to_schema(self) -> Dict[str, Any]:
        """Convert to JSON Schema."""
        ...
    


@dataclass
class NumberType(BaseType):
    """Number type (int or float) with optional constraints."""
    integer_only: bool = ...
    minimum: Optional[float] = ...
    maximum: Optional[float] = ...
    exclusive_minimum: Optional[float] = ...
    exclusive_maximum: Optional[float] = ...
    multiple_of: Optional[float] = ...
    def is_compatible_with(self, other: BaseType) -> bool:
        """Numbers are compatible with other numbers."""
        ...
    
    def validate_value(self, value: Any) -> tuple[bool, Optional[str]]:
        """Validate a value is a number meeting constraints."""
        ...
    
    def to_schema(self) -> Dict[str, Any]:
        """Convert to JSON Schema."""
        ...
    


@dataclass
class BooleanType(BaseType):
    """Boolean type."""
    def is_compatible_with(self, other: BaseType) -> bool:
        """Booleans are compatible with other booleans."""
        ...
    
    def validate_value(self, value: Any) -> tuple[bool, Optional[str]]:
        """Validate a value is a boolean."""
        ...
    
    def to_schema(self) -> Dict[str, Any]:
        """Convert to JSON Schema."""
        ...
    


@dataclass
class NullType(BaseType):
    """Null/None type."""
    def is_compatible_with(self, other: BaseType) -> bool:
        """Null is compatible with other nulls and optional types."""
        ...
    
    def validate_value(self, value: Any) -> tuple[bool, Optional[str]]:
        """Validate a value is None."""
        ...
    
    def to_schema(self) -> Dict[str, Any]:
        """Convert to JSON Schema."""
        ...
    


@dataclass
class ArrayType(BaseType):
    """Array/list type with item type and constraints."""
    item_type: BaseType
    min_items: Optional[int] = ...
    max_items: Optional[int] = ...
    unique_items: bool = ...
    def is_compatible_with(self, other: BaseType) -> bool:
        """Arrays are compatible if item types are compatible."""
        ...
    
    def validate_value(self, value: Any) -> tuple[bool, Optional[str]]:
        """Validate a value is an array meeting constraints."""
        ...
    
    def to_schema(self) -> Dict[str, Any]:
        """Convert to JSON Schema."""
        ...
    


@dataclass
class ObjectType(BaseType):
    """Object/dict type with property types and constraints."""
    properties: Dict[str, BaseType] = ...
    required: Set[str] = ...
    additional_properties: Union[bool, BaseType] = ...
    min_properties: Optional[int] = ...
    max_properties: Optional[int] = ...
    def is_compatible_with(self, other: BaseType) -> bool:
        """Objects are compatible if all required properties are compatible."""
        ...
    
    def validate_value(self, value: Any) -> tuple[bool, Optional[str]]:
        """Validate a value is an object meeting constraints."""
        ...
    
    def to_schema(self) -> Dict[str, Any]:
        """Convert to JSON Schema."""
        ...
    


@dataclass
class TupleType(BaseType):
    """Tuple type with fixed-size array of specific types."""
    item_types: List[BaseType]
    def is_compatible_with(self, other: BaseType) -> bool:
        """Tuples are compatible if same length and all item types compatible."""
        ...
    
    def validate_value(self, value: Any) -> tuple[bool, Optional[str]]:
        """Validate a value is a tuple with correct types."""
        ...
    
    def to_schema(self) -> Dict[str, Any]:
        """Convert to JSON Schema."""
        ...
    


@dataclass
class UnionType(BaseType):
    """Union type (value can be any of several types)."""
    types: List[BaseType]
    def is_compatible_with(self, other: BaseType) -> bool:
        """Union is compatible if any member type is compatible."""
        ...
    
    def validate_value(self, value: Any) -> tuple[bool, Optional[str]]:
        """Validate a value matches at least one union member."""
        ...
    
    def to_schema(self) -> Dict[str, Any]:
        """Convert to JSON Schema."""
        ...
    


@dataclass
class ReferenceType(BaseType):
    """Reference to a named type definition."""
    name: str
    def is_compatible_with(self, other: BaseType) -> bool:
        """References need to be resolved before compatibility check."""
        ...
    
    def validate_value(self, value: Any) -> tuple[bool, Optional[str]]:
        """References must be resolved before validation."""
        ...
    
    def to_schema(self) -> Dict[str, Any]:
        """Convert to JSON Schema."""
        ...
    


@dataclass
class AnyType(BaseType):
    """Any type (no constraints)."""
    def is_compatible_with(self, other: BaseType) -> bool:
        """Any is compatible with everything."""
        ...
    
    def validate_value(self, value: Any) -> tuple[bool, Optional[str]]:
        """Any accepts all values."""
        ...
    
    def to_schema(self) -> Dict[str, Any]:
        """Convert to JSON Schema."""
        ...
    


def optional(type_: BaseType) -> UnionType:
    """Create an optional type (union with null)."""
    ...

def infer_type_from_value(value: Any) -> BaseType:
    """Infer a type from a runtime value."""
    ...

