"""
This type stub file was generated by pyright.
"""

from typing import Any, Literal, Optional, Sequence, Tuple, overload
from lark import Lark, Token, Transformer, Tree
from temple.diagnostics import Diagnostic, DiagnosticCollector
from temple.typed_ast import Block

"""Lark-based parser for Temple templates.

This module provides a Transformer (`ToTypedAST`) that converts the
parse tree produced by `typed_grammar.lark` into typed AST nodes defined in
`temple.typed_ast`.

Grammar Strategy:
- Literal keywords ("if", "for", "include", "set") in rules for clean semantics
- Compound terminals (END_TAG, ELSE_TAG, ELSE_IF_TAG) for closers to avoid LALR ambiguity
- Token class inherits from str, so always check isinstance(Token) before isinstance(str)
"""
GRAMMAR_PATH = ...
def get_parser() -> Lark:
    """Load and return Lark parser for Temple grammar."""
    ...

@overload
def parse_template(text: str, node_collector: Optional[DiagnosticCollector] = ...) -> Block:
    ...

@overload
def parse_template(text: str, node_collector: Optional[DiagnosticCollector] = ..., *, include_raw: Literal[True]) -> Tuple[Block, Tree]:
    ...

def parse_template(text: str, node_collector: Optional[DiagnosticCollector] = ..., include_raw: bool = ...) -> Block | Tuple[Block, Tree]:
    """Parse template text and return AST.

    Args:
        text: Template source text
        node_collector: Optional collector for node-attached diagnostics
        include_raw: If True, return tuple of (AST, raw Lark tree)

    Returns:
        Parsed Block AST, or (Block, Tree) if include_raw=True

    Raises:
        UnexpectedInput: On syntax errors (use parse_with_diagnostics for error collection)
    """
    ...

def parse_with_diagnostics(text: str, node_collector: Optional[DiagnosticCollector] = ...) -> Tuple[Block, Tuple[Diagnostic, ...]]:
    """Parse template text and collect diagnostics.

    Args:
        text: Template source text
        node_collector: Optional collector for both global and node-attached diagnostics

    Returns:
        Tuple of (AST, diagnostics list). AST may be partial if errors occurred.

    Example:
        >>> ast, diagnostics = parse_with_diagnostics("{% if x %}{{ user.name }}")
        >>> len(diagnostics) > 0  # Missing {% end %}
        True
    """
    ...

class _LarkToTypedASTTransformer(Transformer[Block]):
    """Internal transformer: Lark parse tree â†’ Typed AST.

    Handles:
    - text and expression nodes
    - if_stmt with else_if_chain and else_clause
    - for_stmt with loop iteration
    - include_stmt and set_stmt (inline)
    - block wrapping
    """
    def __init__(self, node_collector: Optional[DiagnosticCollector] = ...) -> None:
        ...
    
    def TEXT(self, tk: Token): # -> Text:
        ...
    
    def text(self, items: Sequence[Any]): # -> Text:
        ...
    
    def condition(self, items: Sequence[Any]) -> str:
        ...
    
    def loop_args(self, items: Sequence[Any]) -> str:
        ...
    
    def include_args(self, items: Sequence[Any]) -> str:
        ...
    
    def set_args(self, items: Sequence[Any]) -> str:
        ...
    
    def expr_content(self, items: Sequence[Any]) -> str:
        ...
    
    def expression(self, items: Sequence[Any]): # -> Expression:
        ...
    
    def if_stmt(self, items: Sequence[Any]): # -> If:
        ...
    
    def else_if_chain(self, items: Sequence[Any]): # -> List[Tuple[str, Block]]:
        """Parse else-if chain from compound ELSE_IF_TAG terminals.

        ELSE_IF_TAG captures the entire {% else if CONDITION %} tag.
        Extract condition using same logic as main condition rule would use.
        """
        ...
    
    def else_clause(self, items: Sequence[Any]): # -> Block:
        """Return the else block."""
        ...
    
    def for_stmt(self, items: Sequence[Any]): # -> For:
        ...
    
    def include_stmt(self, items: Sequence[Any]): # -> Include:
        ...
    
    def set_stmt(self, items: Sequence[Any]): # -> None:
        """Placeholder for set statement (not in typed_ast yet)."""
        ...
    
    def inline_stmt(self, items: Sequence[Any]): # -> Any | None:
        """Pass through include or set statement."""
        ...
    
    def block(self, items: Sequence[Any]) -> Block:
        """Wrap items in Block, filtering out None values."""
        ...
    
    def start(self, items: Sequence[Any]) -> Block:
        """Top-level rule wraps into Block."""
        ...
    


__all__ = ["parse_template", "parse_with_diagnostics", "get_parser"]
