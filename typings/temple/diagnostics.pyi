"""
This type stub file was generated by pyright.
"""

from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Sequence, Tuple, Union, overload
from enum import Enum

"""
temple.diagnostics
Parser-agnostic diagnostic types for error reporting.

Provides error, warning, and info diagnostics with source positions
and LSP format conversion. Used by both lark_parser and temple-linter.
"""
@dataclass(frozen=True)
class Position(Sequence[int]):
    """Position in source text (0-indexed).

    Implements a minimal `Sequence` interface so `Position` can be
    unpacked/indexed like a `(line, column)` tuple while remaining
    immutable.
    """
    line: int
    column: int
    @property
    def col(self) -> int:
        ...
    
    def to_lsp(self) -> Dict[str, int]:
        """Convert to LSP Position format (0-indexed)."""
        ...
    
    def __str__(self) -> str:
        ...
    
    def __len__(self) -> int:
        ...
    
    @overload
    def __getitem__(self, index: int) -> int:
        ...
    
    @overload
    def __getitem__(self, index: slice) -> Tuple[int, ...]:
        ...
    
    def __getitem__(self, index: Union[int, slice]): # -> int | tuple[int, ...]:
        ...
    


@dataclass(frozen=True)
class SourceRange(Sequence["Position"]):
    """Range in source text.

    Sequence-like (start, end) for convenient unpacking/indexing while
    remaining immutable.
    """
    start: Position
    end: Position
    def to_lsp(self) -> Dict[str, Dict[str, int]]:
        """Convert to LSP Range format."""
        ...
    
    def __str__(self) -> str:
        ...
    
    @classmethod
    def from_any(cls, value: Any = ..., *, allow_duck: bool = ...) -> SourceRange:
        """Construct a canonical SourceRange from several accepted shapes.

        Accepts a single argument `value` which may be:
        - a `SourceRange` (returned as-is)
        - a `(line, col)` tuple or list -> treated as start tuple
        - any other object (duck-typed) with `.start`/`.end` attributes

        This centralizes duck-typing so callers can pass a single value
        without worrying about tuple vs. SourceRange vs. duck-typed objects.
        """
        ...
    
    def __len__(self) -> int:
        ...
    
    @overload
    def __getitem__(self, index: int) -> Position:
        ...
    
    @overload
    def __getitem__(self, index: slice) -> Tuple[Position, ...]:
        ...
    
    def __getitem__(self, index: Union[int, slice]): # -> Position | tuple[Position, ...]:
        ...
    


class DiagnosticSeverity(Enum):
    """Diagnostic severity levels matching LSP specification."""
    ERROR = ...
    WARNING = ...
    INFORMATION = ...
    HINT = ...


class DiagnosticTag(Enum):
    """Optional tags for diagnostics."""
    UNNECESSARY = ...
    DEPRECATED = ...


@dataclass
class DiagnosticRelatedInformation:
    """Related information for a diagnostic."""
    message: str
    location_uri: str
    location_range: SourceRange
    ...


@dataclass
class Diagnostic:
    """Represents a single diagnostic message (error, warning, etc.)."""
    message: str
    source_range: SourceRange
    severity: DiagnosticSeverity = ...
    code: Optional[str] = ...
    source: str = ...
    related_information: List[DiagnosticRelatedInformation] = ...
    tags: List[DiagnosticTag] = ...
    data: Dict[str, Any] = ...
    start: Optional[Tuple[int, int]] = ...
    end: Optional[Tuple[int, int]] = ...
    def __post_init__(self): # -> None:
        ...
    
    def to_lsp(self) -> Dict[str, Any]:
        """Convert to LSP Diagnostic format.

        Returns:
            Dict with LSP diagnostic fields (range, message, severity, etc.)
        """
        ...
    
    def to_string(self, source_text: Optional[str] = ..., include_context: bool = ...) -> str:
        """Format diagnostic as human-readable string.

        Args:
            source_text: Full source text for context extraction
            include_context: Whether to include source snippet

        Returns:
            Formatted diagnostic string
        """
        ...
    


class DiagnosticCollector:
    """Simple collector for diagnostics (parsing/analysis errors and warnings).

    Aggregates all diagnostics in a single list with convenient methods
    for adding errors and warnings.
    """
    def __init__(self) -> None:
        ...
    
    def add(self, diagnostic: Diagnostic) -> None:
        """Add a diagnostic.

        Args:
            diagnostic: The diagnostic to add
        """
        ...
    
    def add_error(self, message: str, source_range: SourceRange, code: Optional[str] = ...) -> None:
        """Add an error diagnostic.

        Args:
            message: Error message
            source_range: Source location
            code: Optional error code
        """
        ...
    
    def add_warning(self, message: str, source_range: SourceRange, code: Optional[str] = ...) -> None:
        """Add a warning diagnostic.

        Args:
            message: Warning message
            source_range: Source location
            code: Optional warning code
        """
        ...
    
    def has_errors(self) -> bool:
        """Check if any errors were collected."""
        ...
    
    @property
    def diagnostics(self) -> Tuple[Diagnostic, ...]:
        """Get all diagnostics as an immutable tuple.

        Returns:
            Immutable tuple of diagnostics (prevents accidental mutations)
        """
        ...
    
    def clear(self): # -> None:
        """Clear all diagnostics."""
        ...
    
    def serialize(self) -> List[Dict[str, Any]]:
        """Serialize all diagnostics to LSP-like dicts."""
        ...
    


__all__ = ["Position", "SourceRange", "Diagnostic", "DiagnosticSeverity", "DiagnosticTag", "DiagnosticRelatedInformation", "DiagnosticCollector"]
