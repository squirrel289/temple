"""
This type stub file was generated by pyright.
"""

from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Tuple
from enum import Enum

"""
temple.diagnostics
Parser-agnostic diagnostic types for error reporting.

Provides error, warning, and info diagnostics with source positions
and LSP format conversion. Used by both lark_parser and temple-linter.
"""
@dataclass
class Position:
    """Position in source text (0-indexed)."""
    line: int
    column: int
    @property
    def col(self) -> int:
        ...
    
    def to_lsp(self) -> Dict[str, int]:
        """Convert to LSP Position format (0-indexed)."""
        ...
    
    def __str__(self) -> str:
        ...
    


@dataclass
class SourceRange:
    """Range in source text."""
    start: Position
    end: Position
    def to_lsp(self) -> Dict[str, Dict[str, int]]:
        """Convert to LSP Range format."""
        ...
    
    def __str__(self) -> str:
        ...
    


class DiagnosticSeverity(Enum):
    """Diagnostic severity levels matching LSP specification."""
    ERROR = ...
    WARNING = ...
    INFORMATION = ...
    HINT = ...


class DiagnosticTag(Enum):
    """Optional tags for diagnostics."""
    UNNECESSARY = ...
    DEPRECATED = ...


@dataclass
class DiagnosticRelatedInformation:
    """Related information for a diagnostic."""
    message: str
    location_uri: str
    location_range: SourceRange
    ...


@dataclass
class Diagnostic:
    """Represents a single diagnostic message (error, warning, etc.)."""
    message: str
    source_range: SourceRange
    severity: DiagnosticSeverity = ...
    code: Optional[str] = ...
    source: str = ...
    related_information: List[DiagnosticRelatedInformation] = ...
    tags: List[DiagnosticTag] = ...
    data: Dict[str, Any] = ...
    start: Optional[Tuple[int, int]] = ...
    end: Optional[Tuple[int, int]] = ...
    def __post_init__(self): # -> None:
        ...
    
    def to_lsp(self) -> Dict[str, Any]:
        """Convert to LSP Diagnostic format.

        Returns:
            Dict with LSP diagnostic fields (range, message, severity, etc.)
        """
        ...
    
    def to_string(self, source_text: Optional[str] = ..., include_context: bool = ...) -> str:
        """Format diagnostic as human-readable string.

        Args:
            source_text: Full source text for context extraction
            include_context: Whether to include source snippet

        Returns:
            Formatted diagnostic string
        """
        ...
    


class DiagnosticCollector:
    """Collects diagnostics during parsing/analysis."""
    def __init__(self) -> None:
        ...
    
    def add(self, diagnostic: Diagnostic): # -> None:
        """Add a diagnostic."""
        ...
    
    def add_error(self, message: str, source_range: SourceRange, code: Optional[str] = ...): # -> None:
        """Add an error diagnostic."""
        ...
    
    def add_warning(self, message: str, source_range: SourceRange, code: Optional[str] = ...): # -> None:
        """Add a warning diagnostic."""
        ...
    
    def has_errors(self) -> bool:
        """Check if any errors were collected."""
        ...
    
    @property
    def diagnostics(self) -> Tuple[Diagnostic, ...]:
        """Get all diagnostics as an immutable tuple."""
        ...
    
    def clear(self): # -> None:
        """Clear all diagnostics."""
        ...
    
    def serialize(self) -> List[Dict[str, Any]]:
        """Serialize all diagnostics to LSP-like dicts."""
        ...
    


__all__ = ["Position", "SourceRange", "Diagnostic", "DiagnosticSeverity", "DiagnosticTag", "DiagnosticRelatedInformation", "DiagnosticCollector"]
